# basis.net

Основой для сетевого взаимодействия является модуль `basis.net`. Он не реализует конкретного способа сетевого сообщения, но предоставляет базовую функциональность, куда входят:

- класс `AbstractRequest` - абстрактный запрос
- класс `AbstractTransport` - абстрактный транспорт, управляет запросами
- объект `transportDispatcher` - глобальный диспетчер всех транспортов

Другие модули реализуют различные способы сетевого взаимодействия:

- [basis.net.ajax](basis.net.ajax.md) - основной и наиболее часто используемый модуль
- `basis.net.jsonp` - взаимодействие посредством `JSONP`
- `basis.net.soap` - взаимодействие посредством `SOAP`
- `basis.net.upload` - загрузка файлов на сервер

Так же есть модули обеспечивающие дополнительную функциональность:

- [basis.net.action](basis.net.action.md) - фабрика методов, обеспечивающих сетевое взаимодействие
- [basis.net.service](basis.net.service.md) - диспечер транспортов, описывает некоторый сервис (серверный `end-point`)

## Основные принципы работы

Транспорты (наследники `basis.net.AbstractTransport`) создают и управляют запросами. Класс запроса определяется свойством `requestClass`.

Экземпляры наследников `basis.net.AbstractRequest` реализуют интерфейс для формирования, отправки и обработки результатов запроса. Стоит заметить, что экземпляры `basis.net.AbstractRequest` и его наследников используются только внутри транспортов, и их не стоит использовать напрямую.

Транспорт одновременно может выполнять несколько запросов. Количество одновременно выполняющихся запросов определяется свойством `Transport#poolLimit` (по умолчанию равно `null`, что значит "количество не ограничивается"). По достижению лимита, новые запросы ставятся в очередь и выполняются после того, как заканчивают выполнятся предыдущие запросы. Одновременно могут выполняться только запросы с разным маркером или хешем (значением, которое уникально идентифицирует тип запроса). Маркер вычисляется для каждого запроса методом `Transport#poolHashGetter`. В методе доступны все параметры запроса, по которым можно сформировать уникальный маркер. Запрос с одним и тем же хэшом отменяет предыдущий.

В следующем примере запросы будут выполняться параллельно:

```js
var Transport = basis.require('basis.net.ajax').Transport;

var transport = new Transport({
  url: '/users',
  poolLimit: 5,  // можно изменить на 1, чтобы запросы выполнялись последовательно
  poolHashGetter: function(requestData){
    return requestData.params.userId;
  }
});

transport.request({
  params: {
    userId: 123
  }
});
transport.request({
  params: {
    userId: 321
  }
});
```

Классы `AbstractRequest` и `AbstractTransport` (и их наследники) обладают следующим набором событий:

  * `start()` - возникает сразу перед отправкой запроса;
  * `success(responseData)` - возникает при успешном выполнении запроса;
  * `failure(error)` - возникает при неудачном выполнении запроса;
  * `complete()` - возникает при завершении запроса независимо от его статуса.
  * `abort()` - возникает при отмене запроса (вручную или по таймауту);
  * `timeout()` - возникает, когда привышен лимит ожидания

Данные события возникают у экземпляров запросов, далее делегируются их транспорту, а затем общему диспетчеру.

[TODO: request/abort/stop/resume/influence/stateOnAbort]

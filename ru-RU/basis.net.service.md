# basis.net.service

Модуль `basis.net.service` предоставляет единственный класс `Service`. Экземпляры этого класса служат для центализованного производства транспортов, обладающих общим базовым поведением, а так же для общего управляния транспортами относящимися к сервису. Он так реализует механизм сессии, который используется для авторизации, а так же позволяет подписывать запросы.

## Service

`Service` является фабрикой экземпляров `basis.net.AbstractTransport`, имеющих общий механизм формирования запроса и обработки ответов. Обычно используется для реализации взаимодействия с сервисами на стороне сервера (некоторым серверным API). Позволяет описывать общие правила и требования для каждого запроса, например, наличие определенных заголовков, определенный формат ответов или необходимость авторизации с последующей подписью запросов. В одном приложение может использоваться несколько экземпляров `Service`, но чаще всего один.

Свойство `transportClass` определяет какой класс транспорта будет использоваться. По умолчанию иcпользуется класс `basis.net.ajax.Transport`.

```js
var Service = basis.require('basis.net.service');

// создание сервиса
var service = new Service({
  transportClass: {     // новый класс, наследник basis.net.ajax.Transport
    requestHeaders: {   // добавляем заголовок по умолчанию
      Accept: 'application/json'
    }
  }
});
```

Фактически, все настройки транспорта настраиваются через создание нового класса. Это значит, что можно задать любую настройку и добавить любое расширение. В том числе, задать базовое поведение (настройки) для всех запросов, так же через создание класса (свойство `requestClass` в `transportClass`).

На самом деле сервис, создает от заданного класса еще один внутренний класс, которой реализует дополнительную логику сервиса и используется для создания траспортов.

Метод `createTransport(config)` позволяет создать транспорт сервиса. При этом создается экземпляр `transportClass` с конфигурацией, которая передается единственным аргументом метода.

```js
var transport = service.createTransport({
  url: '/users',
  handler: {
    success: function(){
      // ...
    }
  }
});
```

Метод `createAction(config)` делает то же, что и функция `basis.net.action.create` (она и используется внутри). Только он обеспечивает, что создаваемые действия (action) используют метод `createTransport(config)` сервиса, для производства транспорта. Это наиболее частоиспользуемый метод.

```js
var object = new basis.data.Object({
  save: service.createAction({
    url: '/users',
    request: function(){
      // ...
    },
    success: function(data){
      // ...
    }
  })
});
```

### Сессия

Если серверная сторона требует авторизации, необходимо понимать авторизован ли экземпляр `Service` делать запросы, или нет. Для этого используется механизм "сессии". В общем смысле, сессия – это пользовательский сеанс работы с удаленным сервисом. Если сервис авторизован, то сессия будет открыта (open), в противном случае – закрыта (close).

Сам сервис не имеет воможности проверить, авторизован он или нет. Это связанно с тем, что реализации авторизации на стороне сервера сильно разнится, и нельзя получить универсального решения. Поэтому, подобная логика описывается отдельно от сервиса разработчиками приложений. Такой код открывает и закрывает сессию в зависимости от определенных условий.

```js
var Service = basis.require('basis.net.service').Service;
var service = new Service();

// предположим, что для персистентности, текущий ключ сессии хранится в cookie
// получение ключа сессии из cookies
var sessionKey = basis.require('basis.ua').cookies.get('sessionKey');

// при инициализации приложения, проверяем есть ключ сессии,
// и если есть – открываем сессию
if (sessionKey)
  service.openSession(sessionKey); 
```

Для открытия сессии используется метод `openSession(key, data)`. Ему передаются два параметра: ключ сессии (обязательный), и данные сессии (необязательный). Данные сессии могут использоваться для [подписи]() запросов. Закрывается сессия методом `closeSession()`.

По умолчанию, транспорт сервиса не учитывает открыта сессия или нет. Для того, чтобы это учитывалось, сервису необходимо задать свойству `isSecure` значение `true`. В этом случае, транспорты не будут совершать запросы (они будут игнорироваться), если сессия закрыта. Этим поведением управляет свойство `needSignature`, по умолчанию оно установлено в `true`. Значение `false`, для этого свойства, необходимо выставлять только для транспортов, которые должны выполняться независимо от того, открыта сессия или нет. Обычно это запросы на получение ключа сессии (login), его проверки, отмены ключа сессии (logout), напоминание пароля и т.п.

```js
var DataObject = basis.require('basis.data').Object;
var Service = basis.require('basis.net.service').Service;
var cookies = basis.require('basis.ua').cookies;

var service = new Service({
  isSecure: true
});

var profile = new DataObject({
  login: service.createAction({
    needSignature: false,            // иначе запрос не будет выполнятся
    method: 'POST',
    url: '/login',
    request: function(login, pwd){
      return {                       // POST /login
        params: {                    //
          login: login,              // login=[login]&password=[pwd]
          password: pwd              //
        }
      }
    },
    success: function(data){
      // предположим, сервер отдал JSON
      // { "status": "ok", "session": "..." }
      service.openSession(data.session);

      // сохраняем ключ сессии в cookie
      cookies.set('sessionKey', data.session);
    }
  })
});

if (cookies.get('sessionKey'))
  service.openSession(cookies.get('sessionKey')); 
else
  profile.login('test', '123');
```

Так как сессия в общем смысле является пользовательским сеансом, то предполагается, что возможна смена ключа сессии или временная заморозка сессии. В этом случае, пользовательский сеанс включает в себя несколько сеансов (сессий) с удаленным сервисом.

Ситуация потери сессии с удаленым сервисом возможна из-за действия пользователя (пользователь нажал заблокировать или "выйти") или в виду определенных условий клиентской или серверной стороны (пользователь долго не работал с интерфейсом, долго не отправлялись запросы, превышено время жизни сессии). В этом случае не обязательно закрывать сессию, достаточно ее заморозить. Заморозка означает, что возможно продолжение работы с сервисом, при этом смены пользователя (в рамках удаленного сервиса) не предполагается. Поэтому приложение должно максимально сохранить свое состояние, заблокировав интерфейс и предложив, например, форму для ввода только пароля.

Замораживается сессия методом `freeze`, а размораживается методом `unfreeze`. При заморозке все выполняемые запросы обрываются и добавляются в очередь, а при разморозке эти запросы выполняются повторно.

> На данный момент (1.3) сохраняются все запросы. Но это выглядит не безопасным, в будущем этим поведением можно будет управлять.

В случае ошибки запроса, выполняется метод сервиса `isSessionExpiredError`, которому передается запрос (request). Если метод возвращает `true`, то считается, что сессия с удаленным сервисом истекла, и сессия замораживается.

```js
var Service = basis.require('basis.net.service').Service;

var service = new Service({
  isSecure: true,
  isSessionExpiredError: function(request){  // считаем ответы от сервера с кодом 401,
    return request.xhr.status == 401;        // как сигнал, что сессия устарела
  }
});
```

Класс `Service` является наследником `basis.event.Emitter` и его экземпляров возможны события. На данный момент все события связанны с сессией:

- `sessionOpen` – сессия открыта;
- `sessionClose` – сессия закрыта;
- `sessionFreeze` – сессия разморожена;
- `sessionUnfreeze` – сессия заморожена.

## Подпись запросов

Если сервис использует механизм сессии, появляется вохможность подписи запросов. Когда сессия открыта, то каждый раз, перед тем как транспорт собирается выполнить запрос, он передается в вызов метода `signature`. Так же в этот метод передается значение `data`, которое задается при открытии сессии.

```js
var Service = basis.require('basis.net.service').Service;
var service = new Service({
  isSecure: true,
  signature: function(transport, sessionData){
    console.log('sign request', sessionData);
    transport.setParam('session', session.publicKey);
  }
});

service.openSession('key', {
  publicKey: 'value'
});

var transport = service.createTransport();
transport.request();
// sign request { publicKey: 'value' }
```

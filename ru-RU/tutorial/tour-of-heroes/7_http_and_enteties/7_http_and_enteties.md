# Http and Enteties

В нашем приложении мягко говоря отчетливо прослеживается сущность героя. Для подобных случае в `basis.js` существует Entity.

Модуль `basis.entity` расширяет функциональность модуля basis.data и предназначен для описания типизированных моделей данных.

Объявление типа (его создание) выполняется с помощью функции createType. Этой функции передается конфигурация будущего типа, а результатом выполнения является функция-обертка (тип).

В нашем случае создание сущности героя будет выглядеть следующим образом:

```js
var entity = require('basis.entity');

var Hero = entity.createType({
  name: 'Hero',
  fields: {
    // описание полей
  }
});
```

Основной «настройкой» является fields — набор полей, а точнее фиксированный набор ключей поля data. Его нельзя изменить после объявления, и все экземпляры типа обязательно будут содержать заданный набор ключей.

Не менее важным является указание названия типа — name. Это не только помогает в разработке и отладке, но также позволяет осуществлять позднее связывание типов между собой. Если название типа не задается, оно генерируется автоматически. Нельзя объявить тип с именем, которое уже занято. В случае конфликта имен имя для нового типа игнорируется (генерируется автоматически). Таким образом, для одного имени может быть создан только один тип.

Обычно при объявлении типа достаточно указать его название и описать поля. Поэтому у createType есть сокращенный синтаксис, и предыдущий пример может быть описан так(создайте этот файл в вашем проекте):

`app/type/hero.js`:
```js
var entity = require('basis.entity');

var Hero = entity.createType('Hero', {
    id: entity.IntId,
    title: String
});

module.exports = Hero;
```

В приложении как правило много различных моделей, поэтому создадим корнеавой файл `type.js` хранящий ссылки на все наши модели:

`app/type.js`
```js
module.exports = {
    Hero: require('./type/hero')
};
```

В результате в `Hero` будет хранится функция, которая по сути является фабрикой экземпляров и чтобы в дальнейшем заполнить нашу сущность данными можно просто вызывать это функцию с передачей ей объекта со свойствами согласно объявленной сущности. Но в таком виде сущности как правильно используются редко.

```js
Hero({ id: 1, title: 'Your title' });
```

Для ознакомления со всеми возможностями и свойствами `Entity` рекомендуем прочесть соответствющий раздел документации после прохождения этой главы. ([ссылка](https://github.com/basisjs/articles/blob/master/ru-RU/basis.entity.md))

Сущности удобнее всего использовать для синхронизации представлений с данными приходящими с сервера. До этого момента все данные для нашего приложения мы генерировали самостоятельно, но в реальности они приходят с сервера.

Чтобы самим не реализовывать сервер иы используем открытые данные по героям игры Dota с сайта https://www.opendota.com/.

API для получения данных по героями - https://api.opendota.com/api/heroes

Для начала нам нужно немного изменить модель героя созданного выше. т.к. данные отдаваемые https://api.opendota.com/api/heroes выглядят несколько по другому:

```json
{
  attack_type: "Melee",
  id: 1,
  legs: 2,
  localized_name: "Anti-Mage",
  name: "npc_dota_hero_antimage",
  primary_attr: "agi",
}
```

Изменить сущность `Hero`:

`app/type/hero.js`:
```js
var Hero = entity.createType('Hero', {
    id: entity.IntId,
    title: String,
    name: String,
    primary_attr: String,
    attack_type: String
});
```

Но вот проблема - у нас больше нет в ответе поля `title`! Но нам не ведь хочется менять по всеми приложению наше свойство `title`? А что если нам вообще нужно произвести какие-то трансформации с пришедшими данными?

На этот случай у сущностей есть метод `extendReader`, который позволяет приводить приходящие данные к нужному виду.

``app/type/hero.js`:`
```js
var entity = require('basis.entity');

var Hero = entity.createType('Hero', {
    id: entity.IntId,
    title: String,
    name: String,
    primary_attr: String,
    attack_type: String
});

Hero.extendReader(function(data) {
    data.title = data.localized_name;
});

module.exports = Hero;
```

Отлично, с `title` разобрались. Теперь осталось понять как эти данные правильно запросить и передать в представление.

Основой для сетевого взаимодействия является модуль `basis.net`. Он не реализует конкретного способа сетевого сообщения, но предоставляет базовую функциональность.

Но больше всего нас сейчас интерсесует подмодуль `basis.net.action`. Он используется для создания интерфейса между моделью данных приложения и серверным API. а это именно то что нам нужно.

Функция `basis.net.action.create` по переданному конфигу возвращает функцию, которая вызывает метод request созданного экземпляра.

При этом состояние модели синхронизируется с состоянием запроса.

И тут мы подходим к одному важному моменту - в `basis.js` заложена концепция состояний, когда у каждого типа данных в `basis.js` есть несколько состояний:

* `UNDEFINED` — состояние данных неизвестно (состояние по умолчанию)
* `PROCESSING` — данные в процессе загрузки/обработки
* `READY` — данные загружены/обработаны и готовы к использованию
* `ERROR` — во время загрузки/обработки данных произошла ошибка
* `DEPRECATED` — данные устарели и необходимо снова синхронизировать

`basis.net.action` предназначен как раз для того, чтобы создавать функций-заготовки для синхронизации данных моделей и `action.create`, про которую мы говорили, сама переключает данные в нужное состояние по мере изменений их состояний.

`Схема переключения состояний:`

![states](sheme.png)

Но давайте лучше разберем все это на практике!

Сейчас нам нужно для нашей сущности задать `action` синхронизации, для этого у наборов  сущностей есть метод `setSyncAction`, который принимает на вход один параметр `action`, Давайте пропишем его для `Hero`:

``
```js
Hero.all.setSyncAction(action.create({
    url: 'https://api.opendota.com/api/heroes',
    success: function(data) {
        this.setAndDestroyRemoved(Hero.readList(data));
    }
}));
```

Как видно из данного примера `action.create` принимает на вход конфиг с `url` адресом для синхронизации, а так же свойтсво `success` в котором содержится функция которая выполнится, если действия завершится успешно.

При создании `basis.net.action` в качестве параметров может быть использован следующий набор функций:

* `request() `- результат функции будет передан в метод request транспорта;
* `prepare()`- вызывается перед отправкой запроса и служит для подготовки данных;
* `start()`- вызывается при отправке запроса;
* `success(data)` - вызывается при успешном выполнении запроса;
* `failure(error)` - вызывается при неудачном выполнении запроса;
* `abort()` - вызывается при отмене запроса;
* `сomplete()` - вызывается при завершении запроса независимо от его статуса.

Здесь `Hero.readList` это метод которые превратит полученные данные в пригодные для `basis.js` сущности, `setAndDestroyRemoved` запишет эти данные в набор нашей сущности `Hero` и обеспечит их разрушение если они будут удалены.

Теперь в `hero-list` и  `dashboard` нужно немного поменять код привязки `dataSource` добавив в конце `.all`, чтобы указать на набор данных, а также выставить нодам `active: true`, чтобы источник данных синхронизировал свои данные сразу при создании


`app/pages/dashboard/index.js`
```js
module.exports = new Node({
    template: resource('./templates/dashboard.tmpl'),
    childClass: {
        template: `
            <a class="col-1-4">
                <div class="module hero">
                    <h4>{title}</h4>
                </div>
            </a>
        `,
        binding: {
            id: 'data:',
            title: 'data:',
        },
    },
	active: true,
    dataSource: Heroes.all
});
```

`app/components/hero-list/index.js`
```js
var Node = require('basis.ui').Node;
var Hero = require('../hero/index');
var Heroes = require('../../type').Hero;

module.exports = new Node({
    template: resource('./templates/hero-list.tmpl'),
    active: true,
    childClass: Hero,
    selection: true,
    dataSource: Heroes.all
});
```

Крайне рекомендуем прочитать данную [статью](https://habrahabr.ru/post/305292/) про `active` и потребителей, чтобы лучше понять механизмы синхронизации.

Отлично! Теперь мы получаем наши данные с настоящего сервера!

Чтобы приложение было более полноценным давай реализуем еще поиск по героям - мы же не можем заставлять пользователей в ручную искать героев из таких больших списков.

Прежде всего давайте создадим отдельный компонент поиска. Компонент будет максимально простым и не будет сам по себе реализовать никакой логики.

`app/components/search-input/index.js`
```js
var Node = require('basis.ui').Node;

module.exports = new Node({
    template: resource('./templates/search-input.tmpl')
});
```

`app/components/search-input/templates/search-input.tmpl`

```js
<div>
  <label for="search">
    Search: <input type="text" id="search" event-input="input">
  </label>
</div>
```

Обратите внимание чтобы мы предоставили шаблону `event-input="input"`, хотя не написали никаких обработчиков на это действие в js фалйле компонента.
Это сделано для того чтобы определить обработчики на этот `action` в других компонентах в которые он будет встроен.

Вернёмся к `hero-list` компоненту и подключим созданный компонент как сателлит.

``
```js
module.exports = new Node({
    template: resource('./templates/hero-list.tmpl'),
    binding: {
        searchInput: searchInput,
    },
    active: true,
    childClass: Hero,
    selection: true,
    dataSource: Heroes.all
});
```

Теперь можно добавить действия на `input` к нашему компоненту.

```js
searchInput.action.input = function(e) {
    console.log(e.sender.value);
}
```

Через консоль вы можете убедиться что наш обработчик работает. Теперь нам нужно отфильтровать данные в списке согласно тексту который мы набираем в строке поиска.

В случае обычных JS коллекций мы могли бы просто офильтровать данные в списке, через `.filter`, но мы работаем с `datasets`, и фильтровать нам нужно именно их. + нам еще нужен аналог `.slice`, чтобы отобразить только первые 10 героев.

К счастью `basis.js` предоставлет аналог этих функций для работы с `dataset`. Полный вспомогательный функций можно посмотреть в [документации](https://github.com/basisjs/articles/blob/master/ru-RU/basis.data.dataset.md)







